<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Foundation Planner</title>
  <style media="screen">
  canvas{
    border : 1px solid black;
    background-color: darkgrey;
  }
  img{
    height: 50px;
  }
  input{
    max-width: 30px;
  }
  </style>
</head>
<body>
  <img src="img/viereck.png" alt="">
  <input type="text" id="txtVierecke" value="0">
  <img src="img/dreieck.png" alt=""><input type="text" id="txtDreiecke" value="0">
  <input type="checkbox" id="debug" value="0"> DEBUG
  
  <div id="anleitung">3/4 drücken zum anbauen,0 zum Löschen, 5/6 zum rein/raus zoomen</div>
  <canvas id="canvas" width="1000" height="1000"></canvas>
  <script type="text/javascript">
  function sound(src) {
    this.sound = document.createElement("audio");
    this.sound.src = src;
    this.sound.setAttribute("preload", "auto");
    this.sound.setAttribute("controls", "none");
    this.sound.style.display = "none";
    document.body.appendChild(this.sound);
    this.play = function(){
      this.sound.play();
    }
    this.stop = function(){
      this.sound.pause();
    }
  }
  var sndBau = new sound("snd/bau.mp3");
  var sndAbbruch = new sound("snd/abbruch.mp3");
  var debug = document.getElementById('debug').value;
  var vierecke=0;
  var dreiecke=0;
  var sandstoneTextur= new Image();
  var pattern;
  sandstoneTextur.src = "img/sandstoneTextur.jpg";
  sandstoneTextur.onload = function() {
    // console.log("bam");
    // pattern = ctx.createPattern(sandstoneTextur, 'repeat');
    //ctx.fillStyle = pattern;
    //ctx.fillRect(0, 0, 300, 300);
  };
  var canvas = document.querySelector("canvas"),
  ctx = canvas.getContext("2d"),
  rects = [
    {x: 500, y: 510, w: 20, h: 50},
    {x: 550, y: 570, w: 15, h: 30}    // etc.
  ], i = 0, r;
  function vergleichePunkt(a,b,abweichung=0.1){
    if(a.x - abweichung > b.x || a.x + abweichung < b.x) return false;
    if(a.y - abweichung > b.y || a.y + abweichung < b.y) return false;
    return true;
  }

  class Punkt {
    x;
    y;
    constructor(x,y){
      this.x = x;
      this.y = y;
    }

  }

  class Fundament{
    typ;
    name ="";
    p=[];
    nachbarn=[];
    anzNachbarn =0;
    akt=0;
    enabled =false;
    texturSrc;
    textur;
    constructor(p0,p1,t=4,erzeuger=null,akt=0){
      this.akt = akt;

      if (t==3){
        dreiecke++;
        document.getElementById('txtDreiecke').value = dreiecke;
        this.texturSrc= "img/sandstoneTextur2.jpg";
      } else {
        this.texturSrc= "img/sandstoneTextur.jpg";
        vierecke++;
        document.getElementById('txtVierecke').value = vierecke;
      }
      this.typ = t;
      this.name = Math.random().toString(36).substring(2, 4)
      this.nachbarn[0] = erzeuger;
      this.p[0] = p0;
      this.p[1] = p1;
      var a = this.p[0].y - this.p[1].y;
      var b = this.p[0].x - this.p[1].x;
      var c= Math.sqrt(a*a + b*b);
      var winkel = Math.atan(b/a);
      var winkel2 =Math.acos(a/c) +Math.PI;
      // var winkel2= winkel + Math.PI /2;
      // console.log(winkel*180/Math.PI);

      if (t===4){
        this.p[2] = new Punkt(this.p[1].x + a,this.p[1].y -b);
        this.p[3] = new Punkt(this.p[0].x + a,this.p[0].y -b);
      } else if (t===3) {
        var a_halbe = c/2;
        var h = Math.sqrt(c*c - a_halbe*a_halbe);
        // var ph = new Punkt(this.p[1].x + a_halbe*Math.sin(winkel+(this.p[0].y<this.p[1].y?Math.PI:0)),this.p[1].y +a_halbe*Math.cos(winkel+(this.p[0].y<this.p[1].y?Math.PI:0))); //WARUM!!!!???
        if (this.p[0].y<this.p[1].y){
          winkel += Math.PI
        }
        var phX = this.p[1].x + a_halbe*Math.sin(winkel);
        var phY = this.p[1].y + a_halbe*Math.cos(winkel);
        var ph = new Punkt(phX,phY);
        // console.log(ph);
        this.p[2] = new Punkt(ph.x + h*Math.cos(winkel),ph.y - h*Math.sin(winkel));
      }
    }
    print(){
      var ret= "P0("+this.p[0].x+";"+this.p[0].y+")" +"P1("+this.p[1].x+";"+this.p[1].y+")"+ "P2("+this.p[2].x+";"+this.p[2].y+")"+"P3("+this.p[3].x+";"+this.p[3].y+")";
      return ret;
    }
    setAkt(a){
      if (this.anzNachbarn == this.typ) return;
      this.akt=a%this.typ;
      if (this.nachbarn[this.akt] != null) this.setAkt(this.akt+1);
    }

    textureMap() {
      var texture = this.textur;
      var pts = this.p;

      var tris = [[0, 1, 2], [2, 3, 0]]; // Split in two triangles
      var UVMaps = [
        [new Punkt(0,0),new Punkt(340,0),new Punkt(340,340)],
        [new Punkt(0,0),new Punkt(0,0),new Punkt(340,340),new Punkt(0,340)]
      ];
      for (var t=0; t<this.typ-2; t++) {
        var pp = tris[t];
        var x0 = pts[pp[0]].x, x1 = pts[pp[1]].x, x2 = pts[pp[2]].x;
        var y0 = pts[pp[0]].y, y1 = pts[pp[1]].y, y2 = pts[pp[2]].y;
        var u0 = UVMaps[t][pp[0]].x, u1 = UVMaps[t][pp[1]].x, u2 = UVMaps[t][pp[2]].x;
        var v0 = UVMaps[t][pp[0]].y, v1 = UVMaps[t][pp[1]].y, v2 = UVMaps[t][pp[2]].y;
        // Set clipping area so that only pixels inside the triangle will
        // be affected by the image drawing operation
        ctx.save(); ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1);
        ctx.lineTo(x2, y2); ctx.closePath(); ctx.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var delta_a = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var delta_b = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var delta_c = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2
        - v0*u1*x2 - u0*x1*v2;
        var delta_d = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var delta_e = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var delta_f = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2
        - v0*u1*y2 - u0*y1*v2;

        // Draw the transformed image
        ctx.transform(delta_a/delta, delta_d/delta,
        delta_b/delta, delta_e/delta,
        delta_c/delta, delta_f/delta);
        ctx.drawImage(texture, 0, 0);
        ctx.restore();
      }
    }

      zeichne(farbe="yellow",x=0,y=0){
      debug= document.getElementById('debug').checked;
      this.textur = new Image();
      this.textur.src = this.texturSrc;
      this.textur.addEventListener('load', e => {
        ctx.globalAlpha=0.5;
        this.textureMap();
        ctx.globalAlpha=1.0;
      });

      // var tt= ffgg[4].x;
      ctx.beginPath();
      ctx.moveTo(this.p[0].x,this.p[0].y);
      ctx.lineTo(this.p[1].x,this.p[1].y);
      ctx.lineTo(this.p[2].x,this.p[2].y);
      if (this.typ ===4){
        ctx.lineTo(this.p[3].x,this.p[3].y);
      }
      ctx.lineTo(this.p[0].x,this.p[0].y);
      if (ctx.isPointInPath(x, y) && this.anzNachbarn != this.typ){
        this.enabled=true;
        this.setAkt(this.akt+1);
        // console.log(this);
        ctx.fillStyle = "red";
      } else {
        this.enabled=false;
         ctx.fillStyle = farbe;
        // ctx.fillStyle =pattern;
      }
      //Prüfe ob ein Punkt im Pfad liegt(dann überschneidung und neues Polygon weg.)
      ctx.fill();
      ctx.lineWidth=1;
      ctx.strokeStyle="black";
      ctx.stroke();
      ctx.closePath();

      if(this.enabled){


        // console.log(this);
        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(this.p[0+this.akt].x,this.p[0+this.akt].y);
        ctx.lineTo(this.p[(1+this.akt)%this.typ].x,this.p[(1+this.akt)%this.typ].y);
        ctx.lineWidth=5;
        ctx.stroke();
        if (debug){
          ctx.fillStyle = "black";
          ctx.fillText("P0("+Math.floor(this.p[0].x)+";"+Math.floor(this.p[0].y)+")",this.p[0].x,this.p[0].y);
          ctx.fillText("P1("+Math.floor(this.p[1].x)+";"+Math.floor(this.p[1].y)+")",this.p[1].x,this.p[1].y);
          ctx.fillText("P2("+Math.floor(this.p[2].x)+";"+Math.floor(this.p[2].y)+")",this.p[2].x,this.p[2].y);
          if (this.typ ===4){
            ctx.fillText("P3("+Math.floor(this.p[3].x)+";"+Math.floor(this.p[3].y)+")",this.p[3].x,this.p[3].y);
            ctx.fillText(this.name + " " + this.akt,(this.p[0].x+this.p[1].x+this.p[2].x+this.p[2].x)/4-10,(this.p[0].y+this.p[1].y+this.p[2].y+this.p[3].y)/4);
          } else {
            ctx.fillText(this.name + " " + this.akt,(this.p[0].x+this.p[1].x+this.p[2].x)/3,(this.p[0].y+this.p[1].y+this.p[2].y)/3);

          }
        }

      }
      if (debug){
        ctx.fillStyle = "black";
        if (this.typ ===4){
          ctx.fillText(this.name,(this.p[0].x+this.p[1].x+this.p[2].x+this.p[2].x)/4-10,(this.p[0].y+this.p[1].y+this.p[2].y+this.p[3].y)/4);
        } else {
          ctx.fillText(this.name,(this.p[0].x+this.p[1].x+this.p[2].x)/3,(this.p[0].y+this.p[1].y+this.p[2].y)/3);

        }
      }



    }

    erzeugeKind(t=4){
      // console.log(this);
      var tp0 = new Punkt(this.p[0+this.akt].x,this.p[0+this.akt].y);
      var tp1 = new Punkt(this.p[(1+this.akt)%this.typ].x,this.p[(1+this.akt)%this.typ].y);
      // console.log(tp0);
      var ret = new Fundament(tp1,tp0,t,this,this.akt);
      //this.nachbarn[this.akt] = ret;
      //this.anzNachbarn++;
      // console.log(this);
      // console.log(ret);
      function findeKante(p1,p2){
        var ret;
        //Die Reihenfolge ist wichtig zur bestimmung der Kante!
        if (p1 ==0 && p2 ==1) ret = 0;
        if (p1 ==1 && p2 ==2) ret = 1;
        if (p1 ==2 && p2 ==0) ret = 2;
        if (p1 ==2 && p2 ==3) ret = 2;
        if (p1 ==3 && p2 ==0) ret = 3;
        if (p1 ==1 && p2 ==0) ret = 0;
        if (p1 ==2 && p2 ==1) ret = 1;
        if (p1 ==0 && p2 ==2) ret = 2;
        if (p1 ==3 && p2 ==2) ret = 2;
        if (p1 ==0 && p2 ==3) ret = 3;
        return ret;
      }

      for (var i =0; i< fundamente.length;i++){
        var funde=0;
        var kante_alt=0,kante_neu=0;
        //console.log(i);
        for (var j =0; j< fundamente[i].typ;j++){
          //console.log(j);
          for (var k =0; k< ret.typ;k++){
            // console.log(k);
            // console.log(vergleichePunkt(ret.p[k], fundamente[i].p[j]));
            if (vergleichePunkt(ret.p[k], fundamente[i].p[j])){
              funde++;
              // console.log("i"+i+" j:"+j +" k:" +k+ "funde:"+funde);
              // console.log(ret.p[k]);
              if (funde==1){
                kante_alt = j;
                kante_neu = k;
              } else if (funde ==2 ) {
                kante_neu=findeKante(kante_neu,k);
                kante_alt=findeKante(kante_alt,j);
              }
              // console.log("Kante:"+kante_alt);
              // console.log("Kante:"+kante_neu);
            }


          }
          if (funde == 2){
            fundamente[i].nachbarn[kante_alt] = ret;
            fundamente[i].anzNachbarn++;
            ret.anzNachbarn++;
            if (kante_neu!=0){ //Der Erzeuger ist schon bekannt!
              ret.nachbarn[kante_neu] = fundamente[i].nachbarn[kante_alt];
            }
            funde=0;
            // console.log("i:"+i +"k: "+kante_alt+ "   "+ret.name+  " und " + fundamente[i].name +" sind Nachbarn");
          }
        }
      }

      return ret;
    }
    istPunktDrin(punkt){
      var ret = false;
      ctx.beginPath();
      ctx.moveTo(this.p[0].x,this.p[0].y)
      for (var i=1; i < this.typ;i++){
        ctx.lineTo(this.p[i].x,this.p[i].y)
      }
      ret = ctx.isPointInPath(punkt.x,punkt.y);
      ctx.closePath();
      if (ret){
        this.p.forEach((item, i) => {

          if(vergleichePunkt(item,punkt)){
            // console.log(punkt);
            // console.log(item);
            ret = false;
          }
        });

      }
      return ret;
    }
    entferneFundament(){
      //var ursprung = this.nachbarn[0];
      this.nachbarn.forEach((ursprung, i) => {
        if(ursprung!=null){
          for (var jj=0;jj<ursprung.typ;jj++){

            if ( ursprung.nachbarn[jj] == this){
              ursprung.nachbarn[jj] = null;
            }
          }
          ursprung.anzNachbarn--;
        }

      });
      // console.log(ursprung);
      if (this.typ==3){
        dreiecke--;
        document.getElementById('txtDreiecke').value = dreiecke;
      } else {
        vierecke--;
        document.getElementById('txtVierecke').value = vierecke;
      }
    }
  }
  var pp0 = new Punkt(200,200);
  var pp1 = new Punkt(250,200);
  var pp2 = new Punkt(225,225);
  var fundamente= [new Fundament(pp0,pp1,4)];
  fundamente[0].anzNachbarn =0;

  fundamente[0].zeichne("orange");
  // console.log(fundamente[0].istPunktDrin(pp0));



  canvas.onclick = function(e) {
    // important: correct mouse position:
    var rect = this.getBoundingClientRect(),
    x = e.clientX - rect.left,
    y = e.clientY - rect.top,
    i = 0;
    ctx.clearRect(0, 0, canvas.width, canvas.height); // for demo
    while (f = fundamente[i++]){
      f.zeichne("orange",x,y);
    }
  };
  function doMouseDown(e){
    var rect = this.getBoundingClientRect();
    canvas.merkMausX = e.clientX - rect.left;
    canvas.merkMausY = e.clientY - rect.top;
  }
  function doMouseUp(e){
    var rect = this.getBoundingClientRect();
    var difX = canvas.merkMausX - e.clientX + rect.left;
    var difY = canvas.merkMausY - e.clientY + rect.top;
    // if ( difX<=-5 && difX>=5 || difY<=-5 && difY>=5){
    for(iFND=0;iFND<fundamente.length;iFND++) {
      for(iPkt=0;iPkt<fundamente[iFND].typ;iPkt++) {
        fundamente[iFND].p[iPkt].x = fundamente[iFND].p[iPkt].x -difX;
        fundamente[iFND].p[iPkt].y = fundamente[iFND].p[iPkt].y -difY;
      }
      fundamente[iFND].zeichne("orange");
    }
    // }
  }
  window.addEventListener( "keypress", doKeyDown, false )
  canvas.addEventListener("mousedown", doMouseDown);
  canvas.addEventListener("mouseup", doMouseUp);
   
  function doKeyDown(e){
    // console.log(e.keyCode);
    var i=0;
    var f = null
    if (e.keyCode>=51 && e.keyCode <= 52){ //Taste 3 oder 4
      while (f = fundamente[i++]){
        if (f.enabled){
          var neuesFundament = f.erzeugeKind(e.keyCode - 48);
          fundamente.push(neuesFundament);

          var ueberscheidung =false
          for(iFND=0;iFND<fundamente.length;iFND++) {
            for(iPkt=0;iPkt<fundamente[iFND].typ;iPkt++) {
              // console.log(iFND + " " +iPkt + " " +fundamente[iFND].p[iPkt].x+"|"+fundamente[iFND].p[iPkt].y);
              if(neuesFundament.istPunktDrin(fundamente[iFND].p[iPkt])){
                console.log("das neue überlappt einen alten");
                ueberscheidung=true;
              };
            }
            for(iPkt=0;iPkt<neuesFundament.typ;iPkt++) {
              if(fundamente[iFND].istPunktDrin(neuesFundament.p[iPkt])){
                console.log("ein altes würde das neue überlappen");
                ueberscheidung=true;
              };
            }
          }
          if (ueberscheidung){
            fundamente[fundamente.length-1].entferneFundament(fundamente);
            fundamente.pop();
          } else {
            sndBau.play();
          }
        }
        f.zeichne("orange");
      }
    } else if (e.keyCode <= 48) { //Taste 0
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (var ii=0; ii< fundamente.length;ii++){
        f= fundamente[ii];
        if (f.enabled){
          sndAbbruch.play();
          f.entferneFundament(fundamente);
          fundamente.splice(ii,1);
          // console.log("lösche " + ii);
          ii=-1;
          //break;
        } else {
          f.zeichne("orange");
        }
      }
      // console.log(fundamente);
    }else if (e.keyCode==49){ //Taste 1
      while (f = fundamente[i++]){
        if (f.enabled){
          console.log(f);
        }
      }
    } else if (e.keyCode==50){ //Taste 2
      console.log(fundamente);
    } else if (e.keyCode==53 || e.keyCode==54){ //Taste + / -
      function zoom(in =true){
        var faktor =0.8;
        if (in) faktor =1/faktor;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for(iFND=0;iFND<fundamente.length;iFND++) {
          for(iPkt=0;iPkt<fundamente[iFND].typ;iPkt++) {
            fundamente[iFND].p[iPkt].x = fundamente[iFND].p[iPkt].x * faktor;
            fundamente[iFND].p[iPkt].y = fundamente[iFND].p[iPkt].y * faktor;
          }
          fundamente[iFND].zeichne("orange");
        }
      }
      if (e.keyCode==53) zoom(true) else zoom(false);
    }
  }

  </script>
</body>
</html>
